diff --git a/controllers/authenticate.go b/controllers/authenticate.go
index 8b248ad..8122cec 100644
--- a/controllers/authenticate.go
+++ b/controllers/authenticate.go
@@ -268,6 +268,9 @@ func StartAuthenticationSession(env *environment.State, c *gin.Context, route en
     "func": "StartAuthentication",
   })
 
+  // Redirect to after successful authentication
+  redirectTo := c.Request.RequestURI
+
   // Always generate a new authentication session state
   session := sessions.Default(c)
 
@@ -276,7 +279,9 @@ func StartAuthenticationSession(env *environment.State, c *gin.Context, route en
     log.Debug(err.Error())
     return nil, err
   }
+
   session.Set(environment.SessionStateKey, state)
+  session.Set(state, redirectTo)
   err = session.Save()
   if err != nil {
     log.Debug(err.Error())
@@ -284,11 +289,10 @@ func StartAuthenticationSession(env *environment.State, c *gin.Context, route en
   }
 
   logSession := log.WithFields(logrus.Fields{
-    "session.state.key": environment.SessionStateKey,
-    "session.state.state": state,
+    "redirect_to": redirectTo,
+    "state": state,
   })
-  logSession.Debug("Saved session")
-  logSession.Debug("Using session")
+  logSession.Debug("Started session")
   authUrl := env.HydraConfig.AuthCodeURL(state)
   u, err := url.Parse(authUrl)
   return u, err
diff --git a/controllers/exchange.go b/controllers/exchange.go
index 8079f8e..ff2d8e6 100644
--- a/controllers/exchange.go
+++ b/controllers/exchange.go
@@ -31,6 +31,7 @@ func ExchangeAuthorizationCodeCallback(env *environment.State, route environment
     sessionState := v.(string)
 
     log.WithFields(logrus.Fields{"fixme": 1}).Debug("Do we need to cleanup session state once consumed to ensure no reuse?")
+    log.WithFields(logrus.Fields{"state": sessionState}).Debug("Exchange Authorization Code")
 
     requestState := c.Query("state")
     if requestState == "" {
@@ -72,6 +73,13 @@ func ExchangeAuthorizationCodeCallback(env *environment.State, route environment
 
     if token.Valid() == true {
 
+      // Look into session for redirect_to using state
+      var redirectTo string = config.GetString("oauth2.defaultRedirect")
+      redirect := session.Get(sessionState)
+      if redirect != nil {
+        redirectTo = redirect.(string)
+      }
+
       rawIdToken, ok := token.Extra("id_token").(string)
       if !ok {
         c.JSON(http.StatusUnauthorized, gin.H{"error": "No id_token found with access token"})
@@ -95,10 +103,9 @@ func ExchangeAuthorizationCodeCallback(env *environment.State, route environment
       session := sessions.Default(c)
       session.Set(environment.SessionTokenKey, token)
       session.Set(environment.SessionIdTokenKey, idToken)
+      session.Delete(sessionState) // Cleanup session redirect.
       err = session.Save()
       if err == nil {
-        var redirectTo = config.GetString("oauth2.defaultRedirect")
-        log.WithFields(logrus.Fields{"fixme": 1}).Debug("Figure out where to redirect to.")
         log.WithFields(logrus.Fields{"redirect_to": redirectTo}).Debug("Redirecting")
         c.Redirect(http.StatusFound, redirectTo)
         c.Abort()
